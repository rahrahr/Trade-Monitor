Index: gui.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import datetime\r\nimport json\r\nimport re\r\nfrom copy import deepcopy\r\nfrom PyQt5 import QtWidgets, uic, QtCore, QtGui\r\nfrom QuantLib import Date, China, Period\r\nimport traceback\r\n\r\nfrom ui import *\r\nfrom utils import *\r\nimport trade\r\n\r\n\r\nclass Ui(QtWidgets.QMainWindow):\r\n    def __init__(self):\r\n        super(Ui, self).__init__()\r\n        self.resize(1500, 1000)\r\n        layout_1 = QtWidgets.QHBoxLayout()\r\n        layout_2 = QtWidgets.QHBoxLayout()\r\n\r\n        self.trader_ui = TraderUi()\r\n        self.counterparty_ui = CounterpartyUi()\r\n        self.bond_info_ui = BondInfoUi()\r\n        self.transfer_ui = TransferUi()\r\n\r\n        layout_1.addWidget(self.trader_ui)\r\n        layout_1.addWidget(self.counterparty_ui)\r\n        layout_2.addWidget(self.bond_info_ui)\r\n        layout_2.addWidget(self.transfer_ui)\r\n\r\n        mainlayout = QtWidgets.QVBoxLayout()\r\n        mainlayout.addLayout(layout_1, 10)\r\n        mainlayout.addLayout(layout_2, 60)\r\n        widget = QtWidgets.QWidget()\r\n        widget.setLayout(mainlayout)\r\n        self.setCentralWidget(widget)\r\n\r\n        self.bond_info_ui.get_position.clicked.connect(self.getPosition)\r\n        self.bond_info_ui.send_order.clicked.connect(self.sendOrder)\r\n        self.bond_info_ui.is_last_trade.clicked.connect(self.updateTplus1)\r\n        self.bond_info_ui.send_settlement.clicked.connect(self.sendSettlement)\r\n\r\n        self.transfer_ui.send_order.clicked.connect(self.sendTransferOrder)\r\n        self.transfer_ui.is_last_trade.clicked.connect(self.updateTransfer)\r\n\r\n        # create Portfolio instances for all accounts.\r\n        self.portfolios = {}\r\n        portflios = json.load(open('trader.json', encoding='utf-8'))\r\n        for key_1 in portflios.keys():\r\n            for key_2, item_2 in portflios[key_1].items():\r\n                account = key_1 + key_2\r\n                self.portfolios[key_1 + key_2] =\\\r\n                    portfolio_utils.create_portfolio(account)\r\n                # Makes it easier to update json file\r\n                self.portfolios[key_1 + key_2].key_1 = key_1\r\n                self.portfolios[key_1 + key_2].key_2 = key_2\r\n\r\n    def getPosition(self):\r\n        trader_position = json.load(open('trader.json', encoding='utf-8'))[\r\n            self.trader_ui.list_type.currentText()]\r\n\r\n        trader_id = self.trader_ui.account_list.currentText()\r\n        code = self.bond_info_ui.code.text()\r\n\r\n        bond_position = trader_position[trader_id]['position'].get(code, 0)\r\n        cash_position = trader_position[trader_id]['cash']\r\n\r\n        self.bond_info_ui.bond_position.setText(str(bond_position))\r\n        self.bond_info_ui.cash_position.setText(str(cash_position))\r\n\r\n    def _export_trader_info(self):\r\n        excel_utils._export_trader_info(self)\r\n\r\n    def sendOrder(self):\r\n        self.bond_info_ui._export_info()\r\n        self._export_trader_info()\r\n        x = compliance.check_spot_order()\r\n        if ('失败' in x) or ('不合规' in x) or ('不达标' in x):\r\n            error_message = '报单失败，失败原因：\\n'+'!\\n'.join(x.split('！'))\r\n            QtWidgets.QMessageBox().about(self, '错误信息', error_message)\r\n            return False\r\n\r\n        elif '预警' in x:\r\n            error_message = '交易预警：\\n'+'!\\n'.join(x.split('！'))\r\n            QtWidgets.QMessageBox().about(self, '预警', error_message)\r\n\r\n        try:\r\n            trade = trade_utils.create_spot_trade()\r\n            print(trade.trade_time, type(trade.trade_time))\r\n        except:\r\n            QtWidgets.QMessageBox().about(self, '错误信息', traceback.format_exc())\r\n            return False\r\n\r\n        # 更新Portfolio对象\r\n        try:\r\n            account = trade.inside_id\r\n            self.portfolios[account].append_waiting_trade(trade)\r\n            self.portfolios[account].portfolio_update_t0(trade)\r\n            print(self.portfolios[account].all_trade)\r\n            print(self.portfolios[account].now_time, type(self.portfolios[account].now_time))\r\n            print(type(self.portfolios[account].all_trade.iloc[0, 1]))\r\n\r\n            if trade.is_inside_trade:\r\n                account = trade.other_inside_id\r\n                self.portfolios[account].append_waiting_trade(\r\n                    trade.reversed())\r\n                self.portfolios[account].portfolio_update_t0(\r\n                    trade.reversed())\r\n\r\n        except:\r\n            QtWidgets.QMessageBox().about(\r\n                self, '错误信息', traceback.format_exc())\r\n            return False\r\n\r\n        # 写入Excel和json文件\r\n        if not trade.is_inside_trade:\r\n            self.portfolios[trade.inside_id].to_excel()\r\n            self.portfolios[trade.inside_id].to_json()\r\n        else:\r\n            self.portfolios[trade.inside_id].to_excel()\r\n            self.portfolios[trade.other_inside_id].to_excel()\r\n\r\n            self.portfolios[trade.inside_id].to_json()\r\n            portfolio_utils.to_json(self.portfolios[trade.other_inside_id])\r\n\r\n        QtWidgets.QMessageBox().about(self, '', '报单完成')\r\n\r\n    def sendTransferOrder(self):\r\n        self.transfer_ui._export_transfer_info()\r\n        x = compliance.check_transfer_order()\r\n        if x != '交易成功':\r\n            error_message = '转托管报单失败，失败原因：\\n'+'!\\n'.join(x.split('！'))\r\n            QtWidgets.QMessageBox().about(self, '错误信息', error_message)\r\n            return False\r\n\r\n        try:\r\n            trade = trade_utils.create_transfer_trade()\r\n            trade_ = deepcopy(trade)\r\n            trade.settlement_date = trade.trade_time\r\n        except:\r\n            QtWidgets.QMessageBox().about(self, '错误信息', traceback.format_exc())\r\n            return False\r\n\r\n        # 更新Portfolio对象\r\n        try:\r\n            trade.settlement_days == 'T+1'\r\n            account = trade.inside_id\r\n            self.portfolios[account].append_waiting_trade(trade)\r\n            self.portfolios[account].portfolio_update_t0(trade)\r\n\r\n            account = trade.other_inside_id\r\n            self.portfolios[account].append_waiting_trade(\r\n                trade_.reversed())\r\n            self.portfolios[account].portfolio_update_t0(trade_.reversed())\r\n\r\n        except:\r\n            QtWidgets.QMessageBox().about(\r\n                self, '错误信息', traceback.format_exc())\r\n            return False\r\n\r\n        # 写入Excel和json文件\r\n        if not trade.is_inside_trade:\r\n            portfolio_utils.to_excel(self.portfolios[trade.inside_id])\r\n            portfolio_utils.to_json(self.portfolios[trade.inside_id])\r\n        else:\r\n            portfolio_utils.to_excel(self.portfolios[trade.inside_id])\r\n            portfolio_utils.to_excel(self.portfolios[trade.other_inside_id])\r\n\r\n            portfolio_utils.to_json(self.portfolios[trade.inside_id])\r\n            portfolio_utils.to_json(self.portfolios[trade.other_inside_id])\r\n\r\n        QtWidgets.QMessageBox().about(self, '', '报单完成')\r\n\r\n    def sendSettlement(self):\r\n        # 当前账户提交清算申请\r\n        list_type = self.trader_ui.list_type.currentText()\r\n        trader_id = self.trader_ui.account_list.currentText()\r\n        key = list_type + trader_id\r\n\r\n        self.portfolios[key].settle()\r\n        self.hintFailures()\r\n\r\n    def checkSufficiency(self):\r\n        prompt_msg = []\r\n        popup = QtWidgets.QMainWindow(parent=self)\r\n        mainlayout = QtWidgets.QVBoxLayout()\r\n        widget = QtWidgets.QWidget()\r\n        widget.setLayout(mainlayout)\r\n        popup.setCentralWidget(widget)\r\n\r\n        for key in self.portfolios:\r\n            temp_portfolio = deepcopy(self.portfolios[key])\r\n            temp_portfolio.settle()\r\n            bonds_not_enough = temp_portfolio.bonds[temp_portfolio.bonds['par_amount'] < 0]\r\n            if not bonds_not_enough.empty:\r\n                x = bonds_not_enough['bond_code'].to_list()\r\n                msg = ['{}-{}现券持仓不足'.format(key, i) for i in x]\r\n                prompt_msg.extend(msg)\r\n            # display current positions\r\n            df_ = displayDataFrame(temp_portfolio.bonds, key, self)\r\n            mainlayout.addWidget(df_)\r\n\r\n        msg = QtWidgets.QMessageBox()\r\n        text = \"若不进行转托管操作，账户持仓如下，请选择是否进行接下去的操作\"\r\n        msg.setText(text)\r\n        msg.setWindowTitle(\"请选择\")\r\n        msg.setStandardButtons(\r\n            QtWidgets.QMessageBox.No | QtWidgets.QMessageBox.Yes)\r\n        mainlayout.addWidget(msg)\r\n        popup.resize(600, 600)\r\n        popup.show()\r\n        retval = msg.exec_()\r\n        popup.close()\r\n        return prompt_msg, retval\r\n\r\n    def updateTplus1(self):\r\n        # 更新明天到账的T+1交易，调用后now_time会+1\r\n        # 首先检查是否存在需要弥补交易\r\n        prompt_msg, retval = self.checkSufficiency()\r\n        if retval == QtWidgets.QMessageBox.No:\r\n            # 中止本函数运行\r\n            return\r\n\r\n        if prompt_msg:\r\n            msg = QtWidgets.QMessageBox()\r\n            text = \"更新持仓中止，以下现券不足，请选择是否进行自动内部转托管\\n\" + '\\n'.join(prompt_msg)\r\n            msg.setText(text)\r\n            msg.setWindowTitle(\"持仓不足警示\")\r\n            msg.setStandardButtons(\r\n                QtWidgets.QMessageBox.No | QtWidgets.QMessageBox.Yes)\r\n            retval = msg.exec_()\r\n\r\n            # 若选择Yes，则进入此分支，进行自动转托管\r\n            if retval == QtWidgets.QMessageBox.Yes:\r\n                self.autoTransfer()\r\n                QtWidgets.QMessageBox().about(self, '提示信息', '自动转托管完成，请再次点击“完成今日交易”按钮')\r\n                return\r\n            # 若不选择，则继续更新T+1持仓\r\n\r\n        # 更新T+1\r\n        cal = China(China.IB)\r\n        for key in self.portfolios:\r\n            date = self.portfolios[key].now_time\r\n            if isinstance(date, datetime.datetime):\r\n                date = date.date().isoformat().replace('-', '/')\r\n            x = date.split('/')\r\n            ql_date = Date(int(x[2]), int(x[1]), int(x[0]))\r\n            next_trading_day = cal.advance(\r\n                ql_date, Period('1D')).ISO().split('-')\r\n            next_trading_day = ql_date.ISO().replace('-', '/')\r\n            self.portfolios[key].now_time = next_trading_day\r\n            self.portfolios[key].portfolio_update_t1()\r\n            self.portfolios[key].now_time = date\r\n\r\n            self.portfolios[key].to_excel()\r\n            self.portfolios[key].to_json()\r\n            self.portfolios[key].log()\r\n\r\n        QtWidgets.QMessageBox().about(self, '', '更新完成')\r\n\r\n    def updateTransfer(self):\r\n        # 更新明天到账的转托管交易，调用后now_time会+1\r\n        cal = China(China.IB)\r\n        for key in self.portfolios:\r\n            date = self.portfolios[key].now_time\r\n            if isinstance(date, datetime.datetime):\r\n                date = date.date().isoformat().replace('-', '/')\r\n            x = date.split('/')\r\n            ql_date = Date(int(x[2]), int(x[1]), int(x[0]))\r\n            next_trading_day = cal.advance(\r\n                ql_date, Period('1D')).ISO().replace('-', '/')\r\n            self.portfolios[key].now_time = next_trading_day\r\n            self.portfolios[key].portfolio_update_transfer()\r\n            self.portfolios[key].now_time = date\r\n\r\n            self.portfolios[key].to_excel()\r\n            self.portfolios[key].to_json()\r\n            self.portfolios[key].log()\r\n\r\n        QtWidgets.QMessageBox().about(self, '', '更新完成')\r\n\r\n    def autoTransfer(self):\r\n        # 判断各内部账户中是否存在互补，并进行提示\r\n        # 转托管仍需要手动输入\r\n        temp_portfolios = {}\r\n        for key in self.portfolios:\r\n            temp_portfolios[key] = deepcopy(self.portfolios[key])\r\n            temp_portfolios[key].settle()\r\n            bonds_not_enough = temp_portfolios[key].bonds[temp_portfolios.bonds['par_amount'] < 0]\r\n            temp_portfolios[key].unfilled = bonds_not_enough\r\n\r\n    def hintFailures(self):\r\n        popup = QtWidgets.QMainWindow(parent=self)\r\n        mainlayout = QtWidgets.QVBoxLayout()\r\n        widget = QtWidgets.QWidget()\r\n        widget.setLayout(mainlayout)\r\n        popup.setCentralWidget(widget)\r\n\r\n        msg = QtWidgets.QMessageBox()\r\n        msg.setText(\"结算报单完成，该账户以下Trade属于Failed Trade\")\r\n        mainlayout.addWidget(msg)\r\n        \r\n        list_type = self.trader_ui.list_type.currentText()\r\n        trader_id = self.trader_ui.account_list.currentText()\r\n        key = list_type + trader_id\r\n        df = self.portfolios[key].failed_trade\r\n        df = displayDataFrame(df, key, self)\r\n\r\n        mainlayout.addWidget(df)\r\n        popup.resize(600, 600)\r\n        popup.show()\r\nclass PandasModel(QtCore.QAbstractTableModel):\r\n\r\n    def __init__(self, data):\r\n        QtCore.QAbstractTableModel.__init__(self)\r\n        self._data = data\r\n\r\n    def rowCount(self, parent=None):\r\n        return self._data.shape[0]\r\n\r\n    def columnCount(self, parnet=None):\r\n        return self._data.shape[1]\r\n\r\n    def data(self, index, role=QtCore.Qt.DisplayRole):\r\n        if index.isValid():\r\n            if role == QtCore.Qt.DisplayRole:\r\n                return str(self._data.iloc[index.row(), index.column()])\r\n        return None\r\n\r\n    def headerData(self, col, orientation, role):\r\n        if orientation == QtCore.Qt.Horizontal and role == QtCore.Qt.DisplayRole:\r\n            return self._data.columns[col]\r\n        return None\r\n\r\n\r\ndef displayDataFrame(df, title='', parent=None):\r\n    popup = QtWidgets.QMainWindow(parent=parent)\r\n    popup.setWindowTitle(title)\r\n    popup.view = QtWidgets.QTableView()\r\n    model = PandasModel(df)\r\n    popup.view.setModel(model)\r\n    popup.view.resize(800, 400)\r\n    popup.setCentralWidget(popup.view)\r\n    return popup\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/gui.py b/gui.py
--- a/gui.py	(revision e2eb747e1ef0ffb98b8a8af65db8fe8f0f9bb8f3)
+++ b/gui.py	(date 1627219118878)
@@ -270,7 +270,7 @@
             next_trading_day = cal.advance(
                 ql_date, Period('1D')).ISO().replace('-', '/')
             self.portfolios[key].now_time = next_trading_day
-            self.portfolios[key].portfolio_update_transfer()
+            self.portfolios[key].portfolio_update_transfer(direction="in")
             self.portfolios[key].now_time = date
 
             self.portfolios[key].to_excel()
Index: portfolio.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from dataclasses import dataclass\r\nfrom trade import *\r\nimport pandas as pd\r\nimport numpy as np\r\nfrom utils import portfolio_utils\r\n\r\n\r\n@dataclass\r\nclass Portfolio:\r\n    # 记录投资组合\r\n    def __init__(self,\r\n                 account: str,\r\n                 now_time: str,\r\n                 cash: float,\r\n                 bonds: pd.DataFrame):\r\n\r\n        self.account = account\r\n        self.now_time = now_time\r\n        self.cash = cash\r\n        self.freeze_cash = 0\r\n        self.bonds = bonds\r\n        self.all_trade = pd.DataFrame(None,\r\n                                      columns=['bond_code', 'settlement_date',\r\n                                               'direction', 'amount',\r\n                                               'volume', 'par_amount', 'in_bond_code', 'is_settled'])\r\n        self.failed_trade = pd.DataFrame(None,\r\n                                         columns=['bond_code', 'settlement_date',\r\n                                                  'direction', 'amount',\r\n                                                  'volume', 'par_amount', 'in_bond_code', 'is_settled'])\r\n\r\n    @property\r\n    def waiting_trade(self):\r\n        # 保存所有当日不进行结算的交易\r\n        return self.all_trade[self.all_trade.settlement_date > self.now_time]\r\n\r\n    @property\r\n    def waiting_settlement(self):\r\n        # 保存所有当日进行结算的交易\r\n        return self.all_trade[(self.all_trade.settlement_date == self.now_time) & (~self.all_trade.is_settled)]\r\n\r\n    @property\r\n    def free_cash(self):\r\n        return self.cash - self.freeze_cash\r\n\r\n    def append_waiting_trade(self, trade: Trade):\r\n        x = pd.DataFrame([[trade.bond_code, trade.settlement_date,\r\n                           trade.direction, trade.amount,\r\n                           trade.volume, trade.par_amount, trade.is_settled]],\r\n                         columns=['bond_code', 'settlement_date',\r\n                                  'direction', 'amount',\r\n                                  'volume', 'par_amount', 'is_settled'],\r\n                         index=[trade.id])\r\n\r\n        if hasattr(trade, 'in_bond_code'):\r\n            x = pd.DataFrame([[trade.bond_code, trade.settlement_date,\r\n                               trade.direction, trade.amount,\r\n                               trade.volume, trade.par_amount, trade.in_bond_code,\r\n                               trade.is_settled]],\r\n                             columns=['bond_code', 'settlement_date',\r\n                                      'direction', 'amount',\r\n                                      'volume', 'par_amount', 'in_bond_code',\r\n                                      'is_settled'],\r\n                             index=[trade.id])\r\n        self.all_trade = self.all_trade.append(x)\r\n\r\n    def append_failed_trade(self, trade):\r\n        x = pd.DataFrame([[trade.bond_code, trade.settlement_date,\r\n                           trade.direction, trade.amount,\r\n                           trade.volume, trade.par_amount, trade.is_settled]],\r\n                         columns=['bond_code', 'settlement_date',\r\n                                  'direction', 'amount',\r\n                                  'volume', 'par_amount', 'is_settled'],\r\n                         index=[trade.id])\r\n\r\n        if hasattr(trade, 'in_bond_code'):\r\n            x = pd.DataFrame([[trade.bond_code, trade.settlement_date,\r\n                               trade.direction, trade.amount,\r\n                               trade.volume, trade.par_amount, trade.in_bond_code,\r\n                               trade.is_settled]],\r\n                             columns=['bond_code', 'settlement_date',\r\n                                      'direction', 'amount',\r\n                                      'volume', 'par_amount', 'in_bond_code',\r\n                                      'is_settled'],\r\n                             index=[trade.id])\r\n        self.failed_trade = self.failed_trade.append(x)\r\n\r\n    def bonds_add(self, trade):\r\n        # 债券记加\r\n        if trade.bond_code in self.bonds.bond_code.to_list():\r\n            self.bonds.loc[self.bonds.bond_code ==\r\n                           trade.bond_code, \"volume\"] += trade.volume\r\n            self.bonds.loc[self.bonds.bond_code ==\r\n                           trade.bond_code, \"par_amount\"] += trade.par_amount\r\n            self.bonds.loc[self.bonds.bond_code ==\r\n                           trade.bond_code, \"amount\"] += trade.amount\r\n        else:\r\n            new_bond = pd.DataFrame([[self.bonds.shape[0] + 1, trade.bond_code, trade.par_amount, trade.volume, trade.amount]],\r\n                                    columns=[\"number\", \"bond_code\", \"par_amount\", \"volume\", \"amount\"])\r\n            self.bonds = pd.concat([self.bonds, new_bond])\r\n\r\n    def bonds_minus(self, trade):\r\n        # 债券记减\r\n        if trade.volume < max(self.bonds.loc[self.bonds.bond_code == trade.bond_code, \"volume\"].iloc[0], 1):\r\n            self.bonds.loc[self.bonds.bond_code ==\r\n                           trade.bond_code, \"volume\"] -= trade.volume\r\n            self.bonds.loc[self.bonds.bond_code ==\r\n                           trade.bond_code, \"par_amount\"] -= trade.par_amount\r\n            self.bonds.loc[self.bonds.bond_code ==\r\n                           trade.bond_code, \"amount\"] -= trade.amount\r\n        else:\r\n            self.bonds = self.bonds[self.bonds.bond_code != trade.bond_code]\r\n            self.bonds.number = list(range(1, self.bonds.shape[0] + 1))\r\n\r\n    def portfolio_update_t0(self, trade: Trade):\r\n        # 更新现券交易的交易所T+1交易时的T+0的现券转移部分，资金转移放在T+1函数内结算\r\n        # 买入 - 冻结资金增加； 卖出 - 冻结资金不变\r\n        if trade.bond_code[-2:] == \"IB\" or trade.direction == \"转托管\":\r\n            return\r\n        self.now_time = trade.trade_time\r\n        if trade.direction == \"买入\":\r\n            self.freeze_cash += trade.amount\r\n            self.bonds_add(trade)\r\n        elif trade.direction == \"卖出\":\r\n            self.bonds_minus(trade)\r\n\r\n    def portfolio_update_t1(self):\r\n        # 现券交易 - 交易所T+1 - 结算\r\n        # Assumption: 一定结算成功\r\n        trades = self.waiting_settlement[(self.waiting_settlement.bond_code.map(lambda x:x[-2:] != \"IB\")) &\r\n                                         ((self.waiting_settlement.direction == \"买入\") | (self.waiting_settlement.direction == \"卖出\"))]\r\n        if trades.shape[0] == 0:\r\n            return\r\n        for i in trades.index:\r\n            each_trade = trades.loc[i, :]\r\n            if each_trade.direction == \"买入\":\r\n                self.cash -= each_trade.amount\r\n                self.freeze_cash -= each_trade.amount\r\n            elif each_trade.direction == \"卖出\":\r\n                self.cash += each_trade.amount\r\n            self.all_trade.loc[i, \"is_settled\"] = True\r\n\r\n    def transfer_amount_adjust(self, trade):\r\n        # 根据目前尚存的债券数量，对执行的转托管进行调整\r\n        temp_ = self.bonds.loc[self.bonds.bond_code == trade.bond_code,\r\n                               \"par_amount\"] if trade.bond_code in self.bonds.bond_code.to_list() else 0\r\n        trade.par_amount = min(trade.par_amount, temp_)\r\n        trade.volume = trade.par_amount / 100\r\n        trade.amount = min(trade.amount, temp_ * trade.amount/trade.par_amount)\r\n\r\n        self.all_trade.loc[(self.all_trade.index == trade.name) & (\r\n            self.all_trade.direction == \"转托管\"), \"par_amount\"] = trade.par_amount\r\n        self.all_trade.loc[(self.all_trade.index == trade.name) & (\r\n            self.all_trade.direction == \"转托管\"), \"volume\"] = trade.volume\r\n        self.all_trade.loc[(self.all_trade.index == trade.name) & (\r\n            self.all_trade.direction == \"转托管\"), \"amount\"] = trade.amount\r\n        self.all_trade.loc[(self.all_trade.index == trade.name) & (\r\n            self.all_trade.direction == \"转托管-转入\"), \"par_amount\"] = trade.par_amount\r\n        self.all_trade.loc[(self.all_trade.index == trade.name) & (\r\n            self.all_trade.direction == \"转托管-转入\"), \"volume\"] = trade.volume\r\n        self.all_trade.loc[(self.all_trade.index == trade.name) & (\r\n            self.all_trade.direction == \"转托管-转入\"), \"amount\"] = trade.amount\r\n        return trade\r\n\r\n    def portfolio_update_transfer(self, direction=\"out\"):\r\n        # 更新转托管的T+0的记减 - 转出账户\r\n        if direction == \"out\":\r\n            trades = self.waiting_settlement[self.waiting_settlement.direction == \"转托管\"]\r\n            if trades.shape[0] == 0:\r\n                return\r\n            for i in trades.index:\r\n                each_trade = trades.loc[i, :]\r\n                each_trade = self.transfer_amount_adjust(\r\n                    each_trade)  # 对转托管的量进行调整\r\n                if each_trade.par_amount > 0:  # 只有当账户内还存在对应债券时，才会进行转托管\r\n                    self.bonds_minus(each_trade)\r\n                    self.all_trade.loc[(self.all_trade.index == i) & (\r\n                        self.all_trade.direction == \"转托管\"), \"is_settled\"].iloc[0] = True\r\n        # 更新转托管的T+1或T+2的记加 - 转入账户\r\n        elif direction == \"in\":\r\n            trades = self.waiting_settlement[self.waiting_settlement.direction == \"转托管-转入\"]\r\n            if trades.shape[0] == 0:\r\n                return\r\n            for i in trades.index:\r\n                if self.all_trade.loc[(self.all_trade.index == i) & (self.all_trade.direction == \"转托管\"), \"is_settled\"].iloc[0]:\r\n                    each_trade = trades.loc[i, :]\r\n                    self.bonds_add(each_trade)\r\n                    self.all_trade.loc[(self.all_trade.index == i) & (\r\n                        self.all_trade.direction == \"转托管-转入\"), \"is_settled\"].iloc[0] = True\r\n\r\n    def get_NIB_(self, code_trade):\r\n        # 银行间交易单代码结算逻辑\r\n        # 判断能否全部结算\r\n        code = code_trade[\"bond_code\"].iloc[0]\r\n        net_sell_bond = code_trade.loc[code_trade.direction == \"卖出\", \"par_amount\"].sum(\r\n        ) - code_trade.loc[code_trade.direction == \"买入\", \"par_amount\"].sum()\r\n\r\n        net_cost_cash = code_trade.loc[code_trade.direction == \"买入\", \"amount\"].sum(\r\n        ) - code_trade.loc[code_trade.direction == \"卖出\", \"amount\"].sum()\r\n\r\n        if net_sell_bond <= self.bonds.loc[self.bonds.bond_code == code, \"par_amount\"].iloc[0] and net_cost_cash <= self.cash:\r\n            for i in code_trade.index:\r\n                self.all_trade.loc[i, \"is_settled\"] = True  # 所有交易均能结算\r\n            self.cash -= net_cost_cash\r\n            if net_sell_bond < self.bonds.loc[self.bonds.bond_code == code, \"par_amount\"].iloc[0]:\r\n                self.bonds.loc[self.bonds.bond_code ==\r\n                               code, \"volume\"] -= net_sell_bond / 100\r\n                self.bonds.loc[self.bonds.bond_code ==\r\n                               code, \"par_amount\"] -= net_sell_bond\r\n                self.bonds.loc[self.bonds.bond_code ==\r\n                               code, \"amount\"] += net_cost_cash\r\n            else:\r\n                self.bonds = self.bonds[self.bonds.bond_code != code]\r\n                self.bonds.number = list(range(1, self.bonds.shape[0] + 1))\r\n        # 如果不能全部结算，则将不满足条件的去除，剩余的结算\r\n        else:\r\n            sell_trade = code_trade.loc[code_trade.direction == \"卖出\"]\r\n            buy_trade = code_trade.loc[code_trade.direction == \"买入\"]\r\n            if net_sell_bond > self.bonds.loc[self.bonds.bond_code == code, \"par_amount\"]:\r\n                # 卖多了，则从卖出的交易中去除\r\n                max_sell_bond = self.bonds.loc[self.bonds.bond_code ==\r\n                                               code, \"par_amount\"]\r\n                a = sell_trade[\"par_amount\"].to_list()\r\n                b = np.zeros(len(a))\r\n                self.get_nearst(a, begin=0, b=b, M=max_sell_bond)\r\n                for i in range(len(b)):\r\n                    each_trade = sell_trade.iloc[i, :]\r\n                    if b[i]:\r\n                        self.cash += each_trade.amount\r\n                        self.bonds_minus(each_trade)\r\n                        self.all_trade.loc[self.all_trade.index ==\r\n                                           each_trade.name, \"is_settled\"] = True\r\n                    else:\r\n                        self.append_failed_trade(each_trade)\r\n                # 买入的交易全部执行\r\n                for i in buy_trade.index:\r\n                    each_trade = buy_trade.loc[i, :]\r\n                    self.cash -= each_trade.amount\r\n                    self.bonds_add(each_trade)\r\n                    self.all_trade.loc[self.all_trade.index ==\r\n                                       i, \"is_settled\"] = True\r\n            elif net_cost_cash > self.cash:\r\n                # 买多了，则从买入的交易中去除\r\n                max_buy_cash = self.cash\r\n                a = buy_trade[\"amount\"].to_list()\r\n                b = np.zeros(len(a))\r\n                self.get_nearst(a, begin=0, b=b, M=max_buy_cash)\r\n                for i in range(len(b)):\r\n                    each_trade = buy_trade.iloc[i, :]\r\n                    if b[i]:\r\n                        self.cash -= each_trade.amount\r\n                        self.bonds_add(each_trade)\r\n                        self.all_trade.loc[self.all_trade.index ==\r\n                                           each_trade.name, \"is_settled\"] = True\r\n                    else:\r\n                        self.append_failed_trade(each_trade)\r\n                # 卖出的交易全部执行\r\n                for i in sell_trade.index:\r\n                    each_trade = sell_trade.loc[i, :]\r\n                    self.cash += each_trade.amount\r\n                    self.bonds_minus(each_trade)\r\n                    self.all_trade.loc[self.all_trade.index ==\r\n                                       i, \"is_settled\"] = True\r\n\r\n    def settle(self):\r\n        # 单个账户结算\r\n        # 交易所T+1的全部结算成功\r\n        self.portfolio_update_t1()\r\n        # 银行间T+1和T+0的结算排序结算\r\n        trades = self.waiting_settlement[(self.waiting_settlement.bond_code.map(lambda x:x[-2:] == \"IB\")) &\r\n                                         ((self.waiting_settlement.direction == \"买入\") | (self.waiting_settlement.direction == \"卖出\"))]\r\n        trades = trades.sort_values(by=[\"direction\", \"par_amount\"], ascending=(\r\n            False, False))  # 先卖出后买入，票面金额从大到小排序\r\n        code_sig = trades.drop_duplicates(\r\n            subset=[\"bond_code\"]).bond_code.to_list()\r\n        for code in code_sig:\r\n            code_trade = trades.loc[trades.bond_code == code]\r\n            self.get_NIB_(code_trade)\r\n        # 转托管结算\r\n        self.portfolio_update_transfer(direction=\"out\")\r\n\r\n    def to_excel(self):\r\n        portfolio_utils.to_excel(self)\r\n\r\n    def to_json(self):\r\n        portfolio_utils.to_json(self)\r\n\r\n    def log(self):\r\n        log_name = 'logs/log_{}_{}.csv'.format(\r\n            self.account, self.now_time.replace('/', ''))\r\n        self.all_trade.to_csv(log_name)\r\n\r\n    def get_nearst(self, a, begin, b, M):\r\n        # 递归函数，找到一组数中间和最接近且小于M的组合\r\n        if begin >= len(a):\r\n            return M\r\n        k1 = self.get_nearst(a, begin + 1, b, M - a[begin])\r\n        k2 = self.get_nearst(a, begin + 1, b, M)\r\n        if k1 >= 0 and k2 >= 0:\r\n            if k1 <= k2:\r\n                b[begin] = True\r\n                return self.get_nearst(a, begin + 1, b, M - a[begin])\r\n            else:\r\n                b[begin] = False\r\n                return self.get_nearst(a, begin + 1, b, M)\r\n        if k1 >= 0 and k2 < 0:\r\n            b[begin] = True\r\n            return self.get_nearst(a, begin + 1, b, M - a[begin])\r\n        if k1 < 0:\r\n            b[begin] = False\r\n            return self.get_nearst(a, begin + 1, b, M)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/portfolio.py b/portfolio.py
--- a/portfolio.py	(revision e2eb747e1ef0ffb98b8a8af65db8fe8f0f9bb8f3)
+++ b/portfolio.py	(date 1627221509322)
@@ -62,6 +62,7 @@
                                       'is_settled'],
                              index=[trade.id])
         self.all_trade = self.all_trade.append(x)
+        print(self.all_trade)
 
     def append_failed_trade(self, trade):
         x = pd.DataFrame([[trade.bond_code, trade.settlement_date,
@@ -70,7 +71,7 @@
                          columns=['bond_code', 'settlement_date',
                                   'direction', 'amount',
                                   'volume', 'par_amount', 'is_settled'],
-                         index=[trade.id])
+                         index=[trade.name])
 
         if hasattr(trade, 'in_bond_code'):
             x = pd.DataFrame([[trade.bond_code, trade.settlement_date,
@@ -81,7 +82,7 @@
                                       'direction', 'amount',
                                       'volume', 'par_amount', 'in_bond_code',
                                       'is_settled'],
-                             index=[trade.id])
+                             index=[trade.name])
         self.failed_trade = self.failed_trade.append(x)
 
     def bonds_add(self, trade):
@@ -126,7 +127,7 @@
     def portfolio_update_t1(self):
         # 现券交易 - 交易所T+1 - 结算
         # Assumption: 一定结算成功
-        trades = self.waiting_settlement[(self.waiting_settlement.bond_code.map(lambda x:x[-2:] != "IB")) &
+        trades = self.waiting_settlement[(self.waiting_settlement.bond_code.map(lambda x:x[-2:]) != "IB") &
                                          ((self.waiting_settlement.direction == "买入") | (self.waiting_settlement.direction == "卖出"))]
         if trades.shape[0] == 0:
             return
@@ -142,7 +143,7 @@
     def transfer_amount_adjust(self, trade):
         # 根据目前尚存的债券数量，对执行的转托管进行调整
         temp_ = self.bonds.loc[self.bonds.bond_code == trade.bond_code,
-                               "par_amount"] if trade.bond_code in self.bonds.bond_code.to_list() else 0
+                               "par_amount"].iloc[0] if trade.bond_code in self.bonds.bond_code.to_list() else 0
         trade.par_amount = min(trade.par_amount, temp_)
         trade.volume = trade.par_amount / 100
         trade.amount = min(trade.amount, temp_ * trade.amount/trade.par_amount)
@@ -161,7 +162,7 @@
             self.all_trade.direction == "转托管-转入"), "amount"] = trade.amount
         return trade
 
-    def portfolio_update_transfer(self, direction="out"):
+    def portfolio_update_transfer(self, direction="out", other_portfolios=[]):
         # 更新转托管的T+0的记减 - 转出账户
         if direction == "out":
             trades = self.waiting_settlement[self.waiting_settlement.direction == "转托管"]
@@ -174,18 +175,20 @@
                 if each_trade.par_amount > 0:  # 只有当账户内还存在对应债券时，才会进行转托管
                     self.bonds_minus(each_trade)
                     self.all_trade.loc[(self.all_trade.index == i) & (
-                        self.all_trade.direction == "转托管"), "is_settled"].iloc[0] = True
+                        self.all_trade.direction == "转托管"), "is_settled"] = True
         # 更新转托管的T+1或T+2的记加 - 转入账户
         elif direction == "in":
             trades = self.waiting_settlement[self.waiting_settlement.direction == "转托管-转入"]
             if trades.shape[0] == 0:
                 return
             for i in trades.index:
-                if self.all_trade.loc[(self.all_trade.index == i) & (self.all_trade.direction == "转托管"), "is_settled"].iloc[0]:
-                    each_trade = trades.loc[i, :]
-                    self.bonds_add(each_trade)
-                    self.all_trade.loc[(self.all_trade.index == i) & (
-                        self.all_trade.direction == "转托管-转入"), "is_settled"].iloc[0] = True
+                for other_portfolio in other_portfolios:
+                    reflective_trades = portfolio_utils.find_reflective_trades(self, other_portfolio)
+                    if reflective_trades[i]:
+                        each_trade = trades.loc[i, :]
+                        self.bonds_add(each_trade)
+                        self.all_trade.loc[(self.all_trade.index == i) & (
+                            self.all_trade.direction == "转托管-转入"), "is_settled"] = True
 
     def get_NIB_(self, code_trade):
         # 银行间交易单代码结算逻辑
@@ -197,7 +200,11 @@
         net_cost_cash = code_trade.loc[code_trade.direction == "买入", "amount"].sum(
         ) - code_trade.loc[code_trade.direction == "卖出", "amount"].sum()
 
-        if net_sell_bond <= self.bonds.loc[self.bonds.bond_code == code, "par_amount"].iloc[0] and net_cost_cash <= self.cash:
+        try:
+            max_sell_bond = self.bonds.loc[self.bonds.bond_code == code, "par_amount"].iloc[0]
+        except:
+            max_sell_bond = 0
+        if net_sell_bond <= max_sell_bond and net_cost_cash <= self.cash:
             for i in code_trade.index:
                 self.all_trade.loc[i, "is_settled"] = True  # 所有交易均能结算
             self.cash -= net_cost_cash
@@ -215,16 +222,14 @@
         else:
             sell_trade = code_trade.loc[code_trade.direction == "卖出"]
             buy_trade = code_trade.loc[code_trade.direction == "买入"]
-            if net_sell_bond > self.bonds.loc[self.bonds.bond_code == code, "par_amount"]:
+            if net_sell_bond > self.bonds.loc[self.bonds.bond_code == code, "par_amount"].iloc[0]:
                 # 卖多了，则从卖出的交易中去除
-                max_sell_bond = self.bonds.loc[self.bonds.bond_code ==
-                                               code, "par_amount"]
                 a = sell_trade["par_amount"].to_list()
-                b = np.zeros(len(a))
-                self.get_nearst(a, begin=0, b=b, M=max_sell_bond)
-                for i in range(len(b)):
+                self.b = np.zeros(len(a))
+                self.get_nearst(a, begin=0, M=max_sell_bond)
+                for i in range(len(self.b)):
                     each_trade = sell_trade.iloc[i, :]
-                    if b[i]:
+                    if self.b[i]:
                         self.cash += each_trade.amount
                         self.bonds_minus(each_trade)
                         self.all_trade.loc[self.all_trade.index ==
@@ -242,11 +247,11 @@
                 # 买多了，则从买入的交易中去除
                 max_buy_cash = self.cash
                 a = buy_trade["amount"].to_list()
-                b = np.zeros(len(a))
-                self.get_nearst(a, begin=0, b=b, M=max_buy_cash)
-                for i in range(len(b)):
+                self.b = np.zeros(len(a))
+                self.get_nearst(a, begin=0, M=max_buy_cash)
+                for i in range(len(self.b)):
                     each_trade = buy_trade.iloc[i, :]
-                    if b[i]:
+                    if self.b[i]:
                         self.cash -= each_trade.amount
                         self.bonds_add(each_trade)
                         self.all_trade.loc[self.all_trade.index ==
@@ -266,7 +271,7 @@
         # 交易所T+1的全部结算成功
         self.portfolio_update_t1()
         # 银行间T+1和T+0的结算排序结算
-        trades = self.waiting_settlement[(self.waiting_settlement.bond_code.map(lambda x:x[-2:] == "IB")) &
+        trades = self.waiting_settlement[(self.waiting_settlement.bond_code.map(lambda x:x[-2:]) == "IB") &
                                          ((self.waiting_settlement.direction == "买入") | (self.waiting_settlement.direction == "卖出"))]
         trades = trades.sort_values(by=["direction", "par_amount"], ascending=(
             False, False))  # 先卖出后买入，票面金额从大到小排序
@@ -289,22 +294,22 @@
             self.account, self.now_time.replace('/', ''))
         self.all_trade.to_csv(log_name)
 
-    def get_nearst(self, a, begin, b, M):
+    def get_nearst(self, a, begin, M):
         # 递归函数，找到一组数中间和最接近且小于M的组合
         if begin >= len(a):
             return M
-        k1 = self.get_nearst(a, begin + 1, b, M - a[begin])
-        k2 = self.get_nearst(a, begin + 1, b, M)
+        k1 = self.get_nearst(a, begin + 1, M - a[begin])
+        k2 = self.get_nearst(a, begin + 1, M)
         if k1 >= 0 and k2 >= 0:
             if k1 <= k2:
-                b[begin] = True
-                return self.get_nearst(a, begin + 1, b, M - a[begin])
+                self.b[begin] = True
+                return self.get_nearst(a, begin + 1, M - a[begin])
             else:
-                b[begin] = False
-                return self.get_nearst(a, begin + 1, b, M)
+                self.b[begin] = False
+                return self.get_nearst(a, begin + 1, M)
         if k1 >= 0 and k2 < 0:
-            b[begin] = True
-            return self.get_nearst(a, begin + 1, b, M - a[begin])
+            self.b[begin] = True
+            return self.get_nearst(a, begin + 1, M - a[begin])
         if k1 < 0:
-            b[begin] = False
-            return self.get_nearst(a, begin + 1, b, M)
+            self.b[begin] = False
+            return self.get_nearst(a, begin + 1, M)
Index: utils/portfolio_utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import xlwings as xw\r\nimport pandas as pd\r\nimport json\r\nimport sys\r\nimport datetime\r\nfrom portfolio import Portfolio\r\n\r\n_xlsx_path = json.load(\r\n    open('settings.json'), encoding='utf-8')[\"Trade Monitor Path\"]\r\nbook = xw.Book(_xlsx_path)\r\n\r\n\r\ndef create_portfolio(account: str) -> Portfolio:\r\n    sheet = book.sheets[account]\r\n    cash = float(sheet.range('D2').value)\r\n\r\n    now_time = sheet.range('B2').value\r\n    if isinstance(now_time, datetime.datetime):\r\n        now_time = now_time.date().isoformat().replace('-', '/')\r\n\r\n    bonds = sheet.range('A4').expand().options(pd.DataFrame, index=False).value\r\n\r\n    bonds.columns = [\"number\", \"bond_code\",\r\n                     \"par_amount\", \"volume\",\r\n                     \"amount\"]\r\n    bonds.loc[:, [\"number\", \"volume\"]] = bonds.loc[:,\r\n                                                   [\"number\", \"volume\"]].astype(int)\r\n\r\n    return Portfolio(account, now_time, cash, bonds)\r\n\r\n\r\ndef to_excel(portfolio: Portfolio):\r\n    sheet = book.sheets[portfolio.account]\r\n    sheet.range('B2').value = portfolio.now_time\r\n    sheet.range('D2').value = portfolio.cash\r\n\r\n    bonds = portfolio.bonds.set_index('number')\r\n    bonds.columns = ['债券代码', '券面金额（元）', '持仓量（张）', '金额金额（元）']\r\n    bonds.index.name = '编号'\r\n    sheet.range('A4').value = bonds\r\n\r\n\r\ndef to_json(portfolio: Portfolio):\r\n    json_ = json.load(open('trader.json', encoding='utf-8'))\r\n    bonds = portfolio.bonds.loc[:, [\r\n        'bond_code', 'par_amount']].set_index('bond_code')['par_amount'].to_dict()\r\n\r\n    json_[portfolio.key_1][portfolio.key_2] = {}\r\n    json_[portfolio.key_1][portfolio.key_2] = {\"position\": bonds}\r\n    json_[portfolio.key_1][portfolio.key_2][\"cash\"] = portfolio.cash\r\n\r\n    with open('trader.json', 'w') as f:\r\n        json.dump(json_, f)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/utils/portfolio_utils.py b/utils/portfolio_utils.py
--- a/utils/portfolio_utils.py	(revision e2eb747e1ef0ffb98b8a8af65db8fe8f0f9bb8f3)
+++ b/utils/portfolio_utils.py	(date 1627221249844)
@@ -51,3 +51,9 @@
 
     with open('trader.json', 'w') as f:
         json.dump(json_, f)
+
+def find_reflective_trades(a: Portfolio, b: Portfolio):
+    # find whether transfer orders in B has been successfully settled in A
+    transfer_ids = set(a.all_trade.index) and set(b.all_trade.index)
+    result = a.loc[transfer_ids, 'is_settled'].to_dict()
+    return result
Index: trader.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\"\\u5185\\u90e8\\u8d26\\u6237\": {\"A\": {\"position\": {\"210205.IB\": 10000000.0, \"210303.IB\": 35000000.0, \"210006.IB\": 41000000.0}, \"cash\": 88940259.0}, \"B\": {\"position\": {\"019656.SH\": 11000000.0, \"210303.IB\": 20000000.0, \"019654.SH\": 63000000.0}, \"cash\": 27989008.0}}}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/trader.json b/trader.json
--- a/trader.json	(revision e2eb747e1ef0ffb98b8a8af65db8fe8f0f9bb8f3)
+++ b/trader.json	(date 1627221731011)
@@ -1,1 +1,1 @@
-{"\u5185\u90e8\u8d26\u6237": {"A": {"position": {"210205.IB": 10000000.0, "210303.IB": 35000000.0, "210006.IB": 41000000.0}, "cash": 88940259.0}, "B": {"position": {"019656.SH": 11000000.0, "210303.IB": 20000000.0, "019654.SH": 63000000.0}, "cash": 27989008.0}}}
\ No newline at end of file
+{"\u5185\u90e8\u8d26\u6237": {"A": {"position": {"210006.IB": 9980000.0, "210205.IB": 40000000.0, "210303.IB": 15000000.0, "019654.SH": 4000.0}, "cash": 119247310.0}, "B": {"position": {"019656.SH": 10000000.0, "210303.IB": 20000000.0, "019654.SH": 60000000.0}, "cash": 30000000.0}}}
\ No newline at end of file
